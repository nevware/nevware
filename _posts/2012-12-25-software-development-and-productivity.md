---
id: 14
title: Software development and productivity
date: 2012-12-25T14:34:22+00:00
author: "Neville Kuyt"
layout: single
guid: http://www.kuyt.org/?p=14
permalink: /2012/12/25/software-development-and-productivity/
---
Oh boy. This is one of those subjects &#8211; reasonable people can have valid, cogent and totally incompatible views. Here&#8217;s what I&#8217;ve learnt over the past 15 years.

Software developers are mostly interested in writing software; our motivation is basically to make things work. It helps if those things are intrinsically interesting or cool &#8211; games, genetic algorithms, high traffic websites. We like knowing what problems we have to solve, and what constraints and priorities we have to work in. The better developers tend to be fairly impatient with repetitive work &#8211; we want to work on the cool problems, not writing lots of boiler plate or manually packaging a deployment file. We&#8217;re often annoyed at waste &#8211; which is why we often dislike change, because it forces us to discard work we&#8217;ve already done. A lot of the time, our work requires concentrated attention &#8211; &#8220;[flow](http://en.wikipedia.org/wiki/Flow_%28psychology%29 "Flow state article")&#8221; is often mentioned.

In this light, I think there are 3 major aspects to software developers&#8217; productivity.

## Defining the problem

Firstly, they need to never run out of problems to solve; the better they understand those problems, the more likely it is that they&#8217;ll get on with the work. Well understood doesn&#8217;t necessary mean &#8220;documented&#8221;, or &#8220;UML diagram&#8221; &#8211; though this can really help! In a lot of projects, it takes a while for the team to work out what they&#8217;re doing, and productivity in those early days can be very low, despite hard work, because the developer spends time solving the wrong problem.

I remember working on a reporting application many years ago; we were working on a report which would provide insight into the financial performance of everyone in the company, which involved a lot of complicated business logic, and our database machine was a little underpowered. I took on the task of performance optimization &#8211; tuning the SQL queries, recommending new index schemes etc. I thought this was a clearly understood problem &#8211; I just had to take the queries and make them faster. I worked hard for a week or so, and tuned a dozen or so complex stored procedures, taking our nightly batch time from hours to minutes. However, it turned out &#8211; of course &#8211; that the majority of the stored procedures were changing dramatically to reflect the business logic rules my colleague was working on. Because we had a [horrible source code control system](http://en.wikipedia.org/wiki/Microsoft_Visual_SourceSafe "Evil source code control software"), and I had locked out the files, my colleague had no way of seeing my optimizations while he was working; it turned out that we had so many incompatible changes, we had to discard my work. I&#8217;d worked a week, but effectively, my productivity was worse than if I&#8217;d stayed in bed &#8211; at least that way, we wouldn&#8217;t have had to work out what our conflicts were.

So, a &#8220;well understood&#8221; problem is not just one where the requirements are clear, it&#8217;s also important to understand how the problem fits in the wider picture, both architecturally and within the process. This means that a &#8220;top down&#8221; approach, where architects, designers and project managers hand down requirements to the team, can be inefficient, because it&#8217;s hard to avoid conflicts and incompatibilities by looking at a Gantt chart or UML diagram. I much prefer small (5 &#8211; 10 people) teams where everyone works together to solve the problem; to run bigger projects, you find ways of gluing those smaller teams together.

## Tools, process and the environment

Joel Spolsky writes [eloquently](http://www.joelonsoftware.com/articles/fog0000000043.html "The Joel test. ") on the topic of tools and [offices](http://www.joelonsoftware.com/articles/BionicOffice.html "Joel's office post") for software developers; [Peopleware](http://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams "Tom Demarco and Tim Lister's book Peopleware") covers this ground too. I&#8217;ve never worked in a private office as a software developer &#8211; but I have pretty decent noise cancelling headphones, and a Spotify account. However, nowadays, the biggest tooling issues &#8211; in my view &#8211; are not so much the quality of your IDE, or the speed of your hard drive. I don&#8217;t think there are any bad IDEs, and even the cheapest PC you can buy these days has more than enough memory and disk space (though, yes, I do like me a nice SSD).

Far more important is the question &#8220;how long does it take for a new piece of code to get to the customer?&#8221;. This is usually more about the process than an individual developer&#8217;s workstation &#8211; processes like [Continuous Integration](http://martinfowler.com/articles/continuousIntegration.html "Martin Fowler's article on CI") and [Continuous Delivery](http://continuousdelivery.com/ "CD web site") are becoming mainstream, and we&#8217;re investing in automated testing tools and [BDD.](http://en.wikipedia.org/wiki/Behavior-driven_development "Behaviour Driven Development article")

All these processes make a developer more productive &#8211; not just in the financial sense (it takes less time for the work to lead to value), but also because they tend to dramatically reduce the risk of rework. By getting your work through a testing framework within minutes of completing it, you get very quick feedback on whether it&#8217;s right. By pushing work through the entire deployment pipeline every time you commit something, you know very rapidly whether your work will be deployable.

This takes a bit of upfront investment, but platforms like [Heroku](http://www.heroku.com/) and [Appharbor](https://appharbor.com/) work brilliantly for web applications.

## Expectations

Finally, the expectations you place on a developer tend to have big impact on their productivity. For instance, if you say &#8220;get this done next week at all costs&#8221;, you are likely to get it next week &#8211; but at whatever quality level fits in that time frame. If you say &#8220;make sure this scales to a million users&#8221;, you will get exactly that &#8211; though possibly at the expense of complexity that you weren&#8217;t expecting.

A friend of mine worked on a project years ago which was supposed to build a &#8220;Human resource management&#8221; system (this was before these were off the shelf packages). The project had a bunch of constraints and priorities as usual &#8211; time, budget, quality, performance, scalability etc. However, because the application was designed for a multinational, flexibility was a key issue &#8211; different countries have different legal requirements, data requirements, workflows etc. The project stakeholder told the team that he wanted to use the system all around the world &#8211; so they saw flexibility as one of their major priorities.

I met my friend for a drink about a year after they&#8217;d started the project, and he told me what they&#8217;d achieved &#8211; a framework which supported complex, polymorphous data representation. In Visual Basic 3 (yes, it&#8217;s that long ago). The framework was pretty smart &#8211; it could draw data entry forms for those complex, polymorphic data entities, using &#8220;convention over configuration&#8221;. It could cope with multiple database engines, and was able to handle multiple languages and character sets. They&#8217;d written a really cool tool to create and manage the complex, polymorphic data entities, with a &#8220;Microsoft Office&#8221; like workspace, and a custom toolbar. He felt the project had achieved lots, and was really proud of the cool stuff they&#8217;d been doing.

A month later, the project was disbanded &#8211; the project stakeholder got fed up with the project, as it hadn&#8217;t delivered any Human Resource related functionality, just technical infrastructure stuff. He&#8217;d got an external consultant to look at the project and the code, and the feedback was pretty damning &#8211; the complexity of the framework made it unusable for anyone other than the original team, and some of the code was highly suspect.

I never forgot this episode &#8211; and nowadays, I make sure that I always establish every expectation, even the ones that aren&#8217;t very sexy. Maintainability, extensibility, flexibility and code quality don&#8217;t always have to be perfect, but everyone needs to agree when you&#8217;re building something throw-away, and when it has to last. Performance and scalability aren&#8217;t always huge priorities &#8211; but again, no surprises! Resilience and managability often seem unnecessary to developers, but can be a huge pain once the product goes live.

I often like to hand our project stakeholders post it notes (3 for all of the expectations we think apply), and ask them to place them against a list of expectations &#8211; usually, they balance out pretty evenly. I don&#8217;t think I&#8217;ve ever worked on a project where a single aspect was even twice as important as the others, usually, the balance is that one aspect gets four post its and the others all get 3. It is quite common for one or two aspects to be de-prioritized &#8211; &#8220;we don&#8217;t care about maintainability, this is a throw-away application&#8221;, or &#8220;don&#8217;t worry about performance so much, we&#8217;ll throw hardware at it&#8221;.

What&#8217;s all that got to do with productivity? It&#8217;s very easy for developers to get seduced by solving a cool, complex, technical problem to meet one of those expectations, and for that to take a whole lot of time out of the schedule. If that problem is _really_ important, that&#8217;s a great use of their time. However, it can also lead to &#8220;gold plating&#8221;, which by definition harms productivity.