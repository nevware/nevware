---
id: 129
title: 'There goes my job &#8211; again?'
date: 2017-02-27T11:20:23+00:00
author: "Neville Kuyt"
layout: single
guid: http://www.kuyt.org/?p=129
permalink: /2017/02/27/there-goes-my-job-again/
---
A fairly widely reported story last week explains how Microsoft research have created an [AI that can write software](https://www.newscientist.com/article/mg23331144-500-ai-learns-to-write-its-own-code-by-stealing-from-other-programs/). Hacker News went crazy &#8211; as you might expect.

Can an AI write software? Yes &#8211; it clearly can. Writing software means converting sentences a human understands into instructions for a computer; if Google Translate can convert &#8220;where&#8217;s the post office please?&#8221; into 8 other languages, there&#8217;s no obvious reason it couldn&#8217;t convert &#8220;add 12 to 88&#8221; into computer-executable form. In fact, this concept is older than I am &#8211; the venerable [Cobol language](https://en.wikipedia.org/wiki/COBOL) was created in 1959 with the goal of converting &#8220;business language&#8221; into computer programs &#8211; Cobol stands for &#8220;common business language&#8221;. And compared to C, or Fortran, it kinda succeeds &#8211; Cobol source code at first glance is less dense, and most of the keywords look like &#8220;English&#8221;. But programming in Cobol is still programming &#8211; it&#8217;s unlikely that a sales director would be able to use Cobol to work out the monthly commission report.

In the 1990s, we got a lot of hype around 4GLs; in the early 2000&#8217;s, model-driven development and round-trip engineering promised to make software development much more business-friendly. Business people could express their requirements, and they could be converted to executable code automagically.

None of these things really worked. Cobol was a hugely successful language &#8211; but not because it did away with programmers; rather, it was a widely available language that matched the needs of enterprises which were automating for the first time. I don&#8217;t think I&#8217;ve heard anyone say &#8220;4GL&#8221; for about a decade; round-trip engineering foundered with the horrible tools that support it, which hardly helped to simplify life for either developers or business people.

The defining skill of a software developer isn&#8217;t the language they code in &#8211; it&#8217;s the ability to convert requirements into working software. Computers are already helping with this by compiling or interpreting &#8220;human-readable&#8221; code to machine-executable code. It&#8217;s not ridiculous to believe an AI could use a unit test to write code which completes that test, and it&#8217;s not ridiculous to assume an AI could convert a [BDD-style requirement](https://en.wikipedia.org/wiki/Behavior-driven_development) into working software. The [Microsoft research paper](https://openreview.net/pdf?id=ByldLrqlx) says they have taken the first step &#8211; their AI solves coding test problems, which are typically specified as &#8220;write a program which will take a sequence of numbers &#8220;8, 3, 1, 21&#8221; and sort them in ascending order, returning &#8220;1, 3, 8, 21&#8221;. Extending that to a unit test is a logical and manageable step; I could see an environment where a programmer defines the basic structure of the application &#8211; classes with public methods and properties, for instance &#8211; along with the unit tests to specify the behaviour, and have an AI fill in the details.The next jump &#8211; from &#8220;programmer designs structure, AI fill in behaviour&#8221; to &#8220;AI designs structure&#8221; would be a huge jump. It would likely run into similar problems that you get with model-based development, or many object-relational mapping tools &#8211; the level of detail required to allow the AI to make the choices you want it to make would be high, and the level of detail of the specification might be indistinguishable from writing software.To then jump from &#8220;business person defines requirement, AI interprets and builds solution&#8221; &#8211; well, I&#8217;ve been wrong before, but I don&#8217;t think that&#8217;s credible in the next decade, and possibly longer. It would require natural language processing to reach full maturity, and the AI would need a deep understanding of business domains, the way humans view and interact with business processes, and user interface design.So, I think my job is safe for now. Not sure about any computer science graduates leaving university right now, though&#8230;